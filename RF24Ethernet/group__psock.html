<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RF24Ethernet - TCP/IP over RF24Network: Protosockets library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RF24Ethernet - TCP/IP over RF24Network
   &#160;<span id="projectnumber">Beta 1.1</span>
   </div>
   <div id="projectbrief">TMRh20 - Pushing the practical limits of RF24 modules</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Protosockets library</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:psock_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psock_8h.html">psock.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:_2psock_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_2psock_8h.html">psock.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsock__buf.html">psock_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsock.html">psock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga26ae707402e494f3895a9f012a93ea29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)&#160;&#160;&#160;<a class="el" href="group__psock.html#ga86cc77c910c9a27b614fedf3ff8294bf">psock_init</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)</td></tr>
<tr class="separator:ga26ae707402e494f3895a9f012a93ea29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84901a5aa60040e96d272a69977edd22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2ffbb9e554e08a343ae2f9de4bedfdfc">PT_BEGIN</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td></tr>
<tr class="separator:ga84901a5aa60040e96d272a69977edd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d236d1cf34b4e21836edda60247b70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga70d236d1cf34b4e21836edda60247b70">PSOCK_SEND</a>(<a class="el" href="structpsock.html">psock</a>, data, datalen)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, data, datalen))</td></tr>
<tr class="separator:ga70d236d1cf34b4e21836edda60247b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ad55aa96dd1d200cd0fc5a99f6a4f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gab0ad55aa96dd1d200cd0fc5a99f6a4f7">PSOCK_SEND_STR</a>(<a class="el" href="structpsock.html">psock</a>, str)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, str, strlen(str)))</td></tr>
<tr class="memdesc:gab0ad55aa96dd1d200cd0fc5a99f6a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a null-terminated string.  <a href="#gab0ad55aa96dd1d200cd0fc5a99f6a4f7">More...</a><br/></td></tr>
<tr class="separator:gab0ad55aa96dd1d200cd0fc5a99f6a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d9a9201cba1a6db623284c475c6cea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga10d9a9201cba1a6db623284c475c6cea">PSOCK_GENERATOR_SEND</a>(<a class="el" href="structpsock.html">psock</a>, generator, arg)</td></tr>
<tr class="memdesc:ga10d9a9201cba1a6db623284c475c6cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data with a function and send it.  <a href="#ga10d9a9201cba1a6db623284c475c6cea">More...</a><br/></td></tr>
<tr class="separator:ga10d9a9201cba1a6db623284c475c6cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d56800f82bfc7bbf53bb4a659589812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__uipappfunc.html#ga61db1dcb7c760e4dd5d60bf4e5576dca">uip_close</a>()</td></tr>
<tr class="separator:ga5d56800f82bfc7bbf53bb4a659589812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad895ab98c54d9966ff554aa873151751"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gad895ab98c54d9966ff554aa873151751">PSOCK_READBUF</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readbuf(<a class="el" href="structpsock.html">psock</a>))</td></tr>
<tr class="separator:gad895ab98c54d9966ff554aa873151751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d9c0becf7cb32d0aaef466839dd92e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO</a>(<a class="el" href="structpsock.html">psock</a>, c)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readto(<a class="el" href="structpsock.html">psock</a>, c))</td></tr>
<tr class="separator:gab5d9c0becf7cb32d0aaef466839dd92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab2de595d36e9e55dd61f6ecd139162"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga4ab2de595d36e9e55dd61f6ecd139162">PSOCK_DATALEN</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3178402dd725776415bf9745e7bf92ba">psock_datalen</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:ga4ab2de595d36e9e55dd61f6ecd139162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa11b2a1faf395ae2a6626e01c482d5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga905451249dca72ce0385bf2a9ff178ee">PT_EXIT</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td></tr>
<tr class="separator:gafa11b2a1faf395ae2a6626e01c482d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7cc1dba1819f7fcdaa9ff9eed5a08f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gac7cc1dba1819f7fcdaa9ff9eed5a08f4">PSOCK_CLOSE_EXIT</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:gac7cc1dba1819f7fcdaa9ff9eed5a08f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a264bb64ae706d53f572b1d9e4037a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga4a264bb64ae706d53f572b1d9e4037a2">PSOCK_END</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga7b04a0035bef29d905496c23bae066d2">PT_END</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td></tr>
<tr class="separator:ga4a264bb64ae706d53f572b1d9e4037a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ce98ea4d6f22e9d5068b904d4d2447"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3b19f65e48079d8105be2a99b5b4b2ae">psock_newdata</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:ga55ce98ea4d6f22e9d5068b904d4d2447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebfe5c8a7f3173714efdf2df74fc392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL</a>(<a class="el" href="structpsock.html">psock</a>, condition)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga99e43010ec61327164466aa2d902de45">PT_WAIT_UNTIL</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition));</td></tr>
<tr class="separator:ga2ebfe5c8a7f3173714efdf2df74fc392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87ff36af81990e6ffe20d76d5e4606f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gaa87ff36af81990e6ffe20d76d5e4606f">PSOCK_WAIT_THREAD</a>(<a class="el" href="structpsock.html">psock</a>, condition)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition))</td></tr>
<tr class="separator:gaa87ff36af81990e6ffe20d76d5e4606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ae707402e494f3895a9f012a93ea29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)&#160;&#160;&#160;<a class="el" href="group__psock.html#ga86cc77c910c9a27b614fedf3ff8294bf">psock_init</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)</td></tr>
<tr class="separator:ga26ae707402e494f3895a9f012a93ea29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84901a5aa60040e96d272a69977edd22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2ffbb9e554e08a343ae2f9de4bedfdfc">PT_BEGIN</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td></tr>
<tr class="separator:ga84901a5aa60040e96d272a69977edd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d236d1cf34b4e21836edda60247b70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga70d236d1cf34b4e21836edda60247b70">PSOCK_SEND</a>(<a class="el" href="structpsock.html">psock</a>, data, datalen)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, data, datalen))</td></tr>
<tr class="separator:ga70d236d1cf34b4e21836edda60247b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ad55aa96dd1d200cd0fc5a99f6a4f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gab0ad55aa96dd1d200cd0fc5a99f6a4f7">PSOCK_SEND_STR</a>(<a class="el" href="structpsock.html">psock</a>, str)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, str, strlen(str)))</td></tr>
<tr class="memdesc:gab0ad55aa96dd1d200cd0fc5a99f6a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a null-terminated string.  <a href="#gab0ad55aa96dd1d200cd0fc5a99f6a4f7">More...</a><br/></td></tr>
<tr class="separator:gab0ad55aa96dd1d200cd0fc5a99f6a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d9a9201cba1a6db623284c475c6cea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga10d9a9201cba1a6db623284c475c6cea">PSOCK_GENERATOR_SEND</a>(<a class="el" href="structpsock.html">psock</a>, generator, arg)</td></tr>
<tr class="memdesc:ga10d9a9201cba1a6db623284c475c6cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data with a function and send it.  <a href="#ga10d9a9201cba1a6db623284c475c6cea">More...</a><br/></td></tr>
<tr class="separator:ga10d9a9201cba1a6db623284c475c6cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d56800f82bfc7bbf53bb4a659589812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__uipappfunc.html#ga61db1dcb7c760e4dd5d60bf4e5576dca">uip_close</a>()</td></tr>
<tr class="separator:ga5d56800f82bfc7bbf53bb4a659589812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad895ab98c54d9966ff554aa873151751"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gad895ab98c54d9966ff554aa873151751">PSOCK_READBUF</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readbuf(<a class="el" href="structpsock.html">psock</a>))</td></tr>
<tr class="separator:gad895ab98c54d9966ff554aa873151751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d9c0becf7cb32d0aaef466839dd92e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO</a>(<a class="el" href="structpsock.html">psock</a>, c)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readto(<a class="el" href="structpsock.html">psock</a>, c))</td></tr>
<tr class="separator:gab5d9c0becf7cb32d0aaef466839dd92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab2de595d36e9e55dd61f6ecd139162"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga4ab2de595d36e9e55dd61f6ecd139162">PSOCK_DATALEN</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3178402dd725776415bf9745e7bf92ba">psock_datalen</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:ga4ab2de595d36e9e55dd61f6ecd139162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa11b2a1faf395ae2a6626e01c482d5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga905451249dca72ce0385bf2a9ff178ee">PT_EXIT</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td></tr>
<tr class="separator:gafa11b2a1faf395ae2a6626e01c482d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7cc1dba1819f7fcdaa9ff9eed5a08f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gac7cc1dba1819f7fcdaa9ff9eed5a08f4">PSOCK_CLOSE_EXIT</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:gac7cc1dba1819f7fcdaa9ff9eed5a08f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a264bb64ae706d53f572b1d9e4037a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga4a264bb64ae706d53f572b1d9e4037a2">PSOCK_END</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga7b04a0035bef29d905496c23bae066d2">PT_END</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td></tr>
<tr class="separator:ga4a264bb64ae706d53f572b1d9e4037a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ce98ea4d6f22e9d5068b904d4d2447"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA</a>(<a class="el" href="structpsock.html">psock</a>)&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3b19f65e48079d8105be2a99b5b4b2ae">psock_newdata</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:ga55ce98ea4d6f22e9d5068b904d4d2447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebfe5c8a7f3173714efdf2df74fc392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL</a>(<a class="el" href="structpsock.html">psock</a>, condition)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga99e43010ec61327164466aa2d902de45">PT_WAIT_UNTIL</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition));</td></tr>
<tr class="separator:ga2ebfe5c8a7f3173714efdf2df74fc392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87ff36af81990e6ffe20d76d5e4606f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gaa87ff36af81990e6ffe20d76d5e4606f">PSOCK_WAIT_THREAD</a>(<a class="el" href="structpsock.html">psock</a>, condition)&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition))</td></tr>
<tr class="separator:gaa87ff36af81990e6ffe20d76d5e4606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga86cc77c910c9a27b614fedf3ff8294bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga86cc77c910c9a27b614fedf3ff8294bf">psock_init</a> (struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, char *buffer, unsigned int buffersize)</td></tr>
<tr class="separator:ga86cc77c910c9a27b614fedf3ff8294bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712420c615c932642b69c6c0bb8d13ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga712420c615c932642b69c6c0bb8d13ac">PT_THREAD</a> (psock_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, const char *buf, unsigned int len))</td></tr>
<tr class="separator:ga712420c615c932642b69c6c0bb8d13ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7440860cfbffad961f993737932d17d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga7440860cfbffad961f993737932d17d7">PT_THREAD</a> (psock_generator_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned short(*f)(void *), void *arg))</td></tr>
<tr class="separator:ga7440860cfbffad961f993737932d17d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb49ec06eee4fb369d8d3a414143bb14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gadb49ec06eee4fb369d8d3a414143bb14">PT_THREAD</a> (psock_readbuf(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>))</td></tr>
<tr class="separator:gadb49ec06eee4fb369d8d3a414143bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0505ebccc87d4c1ab7b0e875d53839"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga3b0505ebccc87d4c1ab7b0e875d53839">PT_THREAD</a> (psock_readto(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned char c))</td></tr>
<tr class="separator:ga3b0505ebccc87d4c1ab7b0e875d53839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3178402dd725776415bf9745e7bf92ba"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga3178402dd725776415bf9745e7bf92ba">psock_datalen</a> (struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr class="separator:ga3178402dd725776415bf9745e7bf92ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b19f65e48079d8105be2a99b5b4b2ae"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga3b19f65e48079d8105be2a99b5b4b2ae">psock_newdata</a> (struct <a class="el" href="structpsock.html">psock</a> *s)</td></tr>
<tr class="separator:ga3b19f65e48079d8105be2a99b5b4b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The protosocket library provides an interface to the uIP stack that is similar to the traditional BSD socket interface. Unlike programs written for the ordinary uIP event-driven interface, programs written with the protosocket library are executed in a sequential fashion and does not have to be implemented as explicit state machines.</p>
<p>Protosockets only work with TCP connections.</p>
<p>The protosocket library uses <a class="el" href="group__pt.html">Pt</a> protothreads to provide sequential control flow. This makes the protosockets lightweight in terms of memory, but also means that protosockets inherits the functional limitations of protothreads. Each protosocket lives only within a single function. Automatic variables (stack variables) are not retained across a protosocket library function call.</p>
<dl class="section note"><dt>Note</dt><dd>Because the protosocket library uses protothreads, local variables will not always be saved across a call to a protosocket library function. It is therefore advised that local variables are used with extreme care.</dd></dl>
<p>The protosocket library provides functions for sending data without having to deal with retransmissions and acknowledgements, as well as functions for reading data without having to deal with data being split across more than one TCP segment.</p>
<p>Because each protosocket runs as a protothread, the protosocket has to be started with a call to <a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN()</a> at the start of the function in which the protosocket is used. Similarly, the protosocket protothread can be terminated by a call to <a class="el" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT()</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga26ae707402e494f3895a9f012a93ea29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffersize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__psock.html#ga86cc77c910c9a27b614fedf3ff8294bf">psock_init</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a protosocket.</p>
<p>This macro initializes a protosocket and must be called before the protosocket is used. The initialization also specifies the input buffer for the protosocket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket to be initialized</td></tr>
    <tr><td class="paramname">buffer</td><td>(char *) A pointer to the input buffer for the protosocket.</td></tr>
    <tr><td class="paramname">buffersize</td><td>(unsigned int) The size of the input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84901a5aa60040e96d272a69977edd22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2ffbb9e554e08a343ae2f9de4bedfdfc">PT_BEGIN</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the protosocket protothread in a function.</p>
<p>This macro starts the protothread associated with the protosocket and must come before other protosocket calls in the function it is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket to be started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70d236d1cf34b4e21836edda60247b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_SEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">datalen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, data, datalen))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send data.</p>
<p>This macro sends data over a protosocket. The protosocket protothread blocks until all data has been sent and is known to have been received by the remote end of the TCP connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket over which data is to be sent.</td></tr>
    <tr><td class="paramname">data</td><td>(char *) A pointer to the data that is to be sent.</td></tr>
    <tr><td class="paramname">datalen</td><td>(unsigned int) The length of the data that is to be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0ad55aa96dd1d200cd0fc5a99f6a4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_SEND_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, str, strlen(str)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a null-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>Pointer to the protosocket. </td></tr>
    <tr><td class="paramname">str</td><td>The string to be sent. <pre class="fragment">        This function sends a null-terminated string over the
        protosocket.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10d9a9201cba1a6db623284c475c6cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_GENERATOR_SEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">generator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="code" href="structpsock.html">psock</a>)-&gt;<a class="code" href="structpt.html">pt</a>),                  \</div>
<div class="line">           psock_generator_send(<a class="code" href="structpsock.html">psock</a>, generator, arg))</div>
<div class="ttc" id="group__pt_html_ga2f8f70c30b9ee08a103fbd69a4365c4c"><div class="ttname"><a href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a></div><div class="ttdeci">#define PT_WAIT_THREAD(pt, thread)</div><div class="ttdef"><b>Definition:</b> pt.h:192</div></div>
<div class="ttc" id="structpsock_html"><div class="ttname"><a href="structpsock.html">psock</a></div><div class="ttdef"><b>Definition:</b> psock.h:106</div></div>
<div class="ttc" id="structpt_html"><div class="ttname"><a href="structpt.html">pt</a></div><div class="ttdef"><b>Definition:</b> pt.h:54</div></div>
</div><!-- fragment -->
<p>Generate data with a function and send it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>Pointer to the protosocket. </td></tr>
    <tr><td class="paramname">generator</td><td>Pointer to the generator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to the generator function <pre class="fragment">        This function generates data and sends it over the
        protosocket. This can be used to dynamically generate
        data for a transmission, instead of generating the data
        in a buffer beforehand. This function reduces the need for
        buffer memory. The generator function is implemented by
        the application, and a pointer to the function is given
        as an argument with the call to PSOCK_GENERATOR_SEND().

        The generator function should place the generated data
        directly in the uip_appdata buffer, and return the
        length of the generated data. The generator function is
        called by the protosocket layer when the data first is
        sent, and once for every retransmission that is needed.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d56800f82bfc7bbf53bb4a659589812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_CLOSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__uipappfunc.html#ga61db1dcb7c760e4dd5d60bf4e5576dca">uip_close</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a protosocket.</p>
<p>This macro closes a protosocket and can only be called from within the protothread in which the protosocket lives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket that is to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad895ab98c54d9966ff554aa873151751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_READBUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readbuf(<a class="el" href="structpsock.html">psock</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data until the buffer is full.</p>
<p>This macro will block waiting for data and read the data into the input buffer specified with the call to <a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT()</a>. Data is read until the buffer is full..</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket from which data should be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5d9c0becf7cb32d0aaef466839dd92e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_READTO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readto(<a class="el" href="structpsock.html">psock</a>, c))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data up to a specified character.</p>
<p>This macro will block waiting for data and read the data into the input buffer specified with the call to <a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT()</a>. Data is only read until the specifieed character appears in the data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket from which data should be read.</td></tr>
    <tr><td class="paramname">c</td><td>(char) The character at which to stop reading. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ab2de595d36e9e55dd61f6ecd139162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_DATALEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3178402dd725776415bf9745e7bf92ba">psock_datalen</a>(<a class="el" href="structpsock.html">psock</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the data that was previously read.</p>
<p>This macro returns the length of the data that was previously read using <a class="el" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO()</a> or PSOCK_READ().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket holding the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa11b2a1faf395ae2a6626e01c482d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_EXIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga905451249dca72ce0385bf2a9ff178ee">PT_EXIT</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the protosocket's protothread.</p>
<p>This macro terminates the protothread of the protosocket and should almost always be used in conjunction with <a class="el" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__psock.html#gac7cc1dba1819f7fcdaa9ff9eed5a08f4">PSOCK_CLOSE_EXIT()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7cc1dba1819f7fcdaa9ff9eed5a08f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_CLOSE_EXIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                        <a class="code" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">\</a></div>
<div class="line"><a class="code" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">    PSOCK_CLOSE</a>(<a class="code" href="structpsock.html">psock</a>);         <a class="code" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">\</a></div>
<div class="line"><a class="code" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">    PSOCK_EXIT</a>(<a class="code" href="structpsock.html">psock</a>);          \</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="group__psock_html_ga5d56800f82bfc7bbf53bb4a659589812"><div class="ttname"><a href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE</a></div><div class="ttdeci">#define PSOCK_CLOSE(psock)</div><div class="ttdef"><b>Definition:</b> psock.h:235</div></div>
<div class="ttc" id="structpsock_html"><div class="ttname"><a href="structpsock.html">psock</a></div><div class="ttdef"><b>Definition:</b> psock.h:106</div></div>
<div class="ttc" id="group__psock_html_gafa11b2a1faf395ae2a6626e01c482d5d"><div class="ttname"><a href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT</a></div><div class="ttdeci">#define PSOCK_EXIT(psock)</div><div class="ttdef"><b>Definition:</b> psock.h:297</div></div>
</div><!-- fragment --><p>Close a protosocket and exit the protosocket's protothread.</p>
<p>This macro closes a protosocket and exits the protosocket's protothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a264bb64ae706d53f572b1d9e4037a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga7b04a0035bef29d905496c23bae066d2">PT_END</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the end of a protosocket's protothread.</p>
<p>This macro is used for declaring that the protosocket's protothread ends. It must always be used together with a matching <a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga55ce98ea4d6f22e9d5068b904d4d2447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_NEWDATA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3b19f65e48079d8105be2a99b5b4b2ae">psock_newdata</a>(<a class="el" href="structpsock.html">psock</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if new data has arrived on a protosocket.</p>
<p>This macro is used in conjunction with the <a class="el" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL()</a> macro to check if data has arrived on a protosocket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2ebfe5c8a7f3173714efdf2df74fc392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_WAIT_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga99e43010ec61327164466aa2d902de45">PT_WAIT_UNTIL</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition));</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until a condition is true.</p>
<p>This macro blocks the protothread until the specified condition is true. The macro <a class="el" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA()</a> can be used to check if new data arrives when the protosocket is waiting.</p>
<p>Typically, this macro is used as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="group__pt.html#ga3d4c8bd4aada659eb34f5d2ffd3e7901">PT_THREAD</a>(thread(<span class="keyword">struct</span> <a class="code" href="structpsock.html">psock</a> *s, <span class="keyword">struct</span> <a class="code" href="structtimer.html">timer</a> *t))</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN</a>(s);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL</a>(s, PSOCK_NEWADATA(s) || <a class="code" href="group__timer.html#ga6d71dececfce707c668e6257aad5906e">timer_expired</a>(t));</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA</a>(s)) {</div>
<div class="line">    <a class="code" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO</a>(s, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    handle_timed_out(s);</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <a class="code" href="group__psock.html#ga4a264bb64ae706d53f572b1d9e4037a2">PSOCK_END</a>(s);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
    <tr><td class="paramname">condition</td><td>The condition to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa87ff36af81990e6ffe20d76d5e4606f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_WAIT_THREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga26ae707402e494f3895a9f012a93ea29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffersize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__psock.html#ga86cc77c910c9a27b614fedf3ff8294bf">psock_init</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a protosocket.</p>
<p>This macro initializes a protosocket and must be called before the protosocket is used. The initialization also specifies the input buffer for the protosocket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket to be initialized</td></tr>
    <tr><td class="paramname">buffer</td><td>(char *) A pointer to the input buffer for the protosocket.</td></tr>
    <tr><td class="paramname">buffersize</td><td>(unsigned int) The size of the input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84901a5aa60040e96d272a69977edd22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2ffbb9e554e08a343ae2f9de4bedfdfc">PT_BEGIN</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the protosocket protothread in a function.</p>
<p>This macro starts the protothread associated with the protosocket and must come before other protosocket calls in the function it is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket to be started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70d236d1cf34b4e21836edda60247b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_SEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">datalen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, data, datalen))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send data.</p>
<p>This macro sends data over a protosocket. The protosocket protothread blocks until all data has been sent and is known to have been received by the remote end of the TCP connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket over which data is to be sent.</td></tr>
    <tr><td class="paramname">data</td><td>(char *) A pointer to the data that is to be sent.</td></tr>
    <tr><td class="paramname">datalen</td><td>(unsigned int) The length of the data that is to be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0ad55aa96dd1d200cd0fc5a99f6a4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_SEND_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_send(<a class="el" href="structpsock.html">psock</a>, str, strlen(str)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a null-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>Pointer to the protosocket. </td></tr>
    <tr><td class="paramname">str</td><td>The string to be sent. <pre class="fragment">        This function sends a null-terminated string over the
        protosocket.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10d9a9201cba1a6db623284c475c6cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_GENERATOR_SEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">generator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="code" href="structpsock.html">psock</a>)-&gt;<a class="code" href="structpt.html">pt</a>),                  \</div>
<div class="line">           psock_generator_send(<a class="code" href="structpsock.html">psock</a>, generator, arg))</div>
<div class="ttc" id="group__pt_html_ga2f8f70c30b9ee08a103fbd69a4365c4c"><div class="ttname"><a href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a></div><div class="ttdeci">#define PT_WAIT_THREAD(pt, thread)</div><div class="ttdef"><b>Definition:</b> pt.h:192</div></div>
<div class="ttc" id="structpsock_html"><div class="ttname"><a href="structpsock.html">psock</a></div><div class="ttdef"><b>Definition:</b> psock.h:106</div></div>
<div class="ttc" id="structpt_html"><div class="ttname"><a href="structpt.html">pt</a></div><div class="ttdef"><b>Definition:</b> pt.h:54</div></div>
</div><!-- fragment -->
<p>Generate data with a function and send it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>Pointer to the protosocket. </td></tr>
    <tr><td class="paramname">generator</td><td>Pointer to the generator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to the generator function <pre class="fragment">        This function generates data and sends it over the
        protosocket. This can be used to dynamically generate
        data for a transmission, instead of generating the data
        in a buffer beforehand. This function reduces the need for
        buffer memory. The generator function is implemented by
        the application, and a pointer to the function is given
        as an argument with the call to PSOCK_GENERATOR_SEND().

        The generator function should place the generated data
        directly in the uip_appdata buffer, and return the
        length of the generated data. The generator function is
        called by the protosocket layer when the data first is
        sent, and once for every retransmission that is needed.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d56800f82bfc7bbf53bb4a659589812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_CLOSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__uipappfunc.html#ga61db1dcb7c760e4dd5d60bf4e5576dca">uip_close</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a protosocket.</p>
<p>This macro closes a protosocket and can only be called from within the protothread in which the protosocket lives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket that is to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad895ab98c54d9966ff554aa873151751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_READBUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readbuf(<a class="el" href="structpsock.html">psock</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data until the buffer is full.</p>
<p>This macro will block waiting for data and read the data into the input buffer specified with the call to <a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT()</a>. Data is read until the buffer is full..</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket from which data should be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5d9c0becf7cb32d0aaef466839dd92e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_READTO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), psock_readto(<a class="el" href="structpsock.html">psock</a>, c))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data up to a specified character.</p>
<p>This macro will block waiting for data and read the data into the input buffer specified with the call to <a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT()</a>. Data is only read until the specifieed character appears in the data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket from which data should be read.</td></tr>
    <tr><td class="paramname">c</td><td>(char) The character at which to stop reading. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ab2de595d36e9e55dd61f6ecd139162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_DATALEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3178402dd725776415bf9745e7bf92ba">psock_datalen</a>(<a class="el" href="structpsock.html">psock</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the data that was previously read.</p>
<p>This macro returns the length of the data that was previously read using <a class="el" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO()</a> or PSOCK_READ().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket holding the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa11b2a1faf395ae2a6626e01c482d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_EXIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga905451249dca72ce0385bf2a9ff178ee">PT_EXIT</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the protosocket's protothread.</p>
<p>This macro terminates the protothread of the protosocket and should almost always be used in conjunction with <a class="el" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__psock.html#gac7cc1dba1819f7fcdaa9ff9eed5a08f4">PSOCK_CLOSE_EXIT()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7cc1dba1819f7fcdaa9ff9eed5a08f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_CLOSE_EXIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                        <a class="code" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">\</a></div>
<div class="line"><a class="code" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">    PSOCK_CLOSE</a>(<a class="code" href="structpsock.html">psock</a>);         <a class="code" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">\</a></div>
<div class="line"><a class="code" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">    PSOCK_EXIT</a>(<a class="code" href="structpsock.html">psock</a>);          \</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="group__psock_html_ga5d56800f82bfc7bbf53bb4a659589812"><div class="ttname"><a href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE</a></div><div class="ttdeci">#define PSOCK_CLOSE(psock)</div><div class="ttdef"><b>Definition:</b> psock.h:235</div></div>
<div class="ttc" id="structpsock_html"><div class="ttname"><a href="structpsock.html">psock</a></div><div class="ttdef"><b>Definition:</b> psock.h:106</div></div>
<div class="ttc" id="group__psock_html_gafa11b2a1faf395ae2a6626e01c482d5d"><div class="ttname"><a href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT</a></div><div class="ttdeci">#define PSOCK_EXIT(psock)</div><div class="ttdef"><b>Definition:</b> psock.h:297</div></div>
</div><!-- fragment --><p>Close a protosocket and exit the protosocket's protothread.</p>
<p>This macro closes a protosocket and exits the protosocket's protothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a264bb64ae706d53f572b1d9e4037a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga7b04a0035bef29d905496c23bae066d2">PT_END</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the end of a protosocket's protothread.</p>
<p>This macro is used for declaring that the protosocket's protothread ends. It must always be used together with a matching <a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga55ce98ea4d6f22e9d5068b904d4d2447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_NEWDATA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__psock.html#ga3b19f65e48079d8105be2a99b5b4b2ae">psock_newdata</a>(<a class="el" href="structpsock.html">psock</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if new data has arrived on a protosocket.</p>
<p>This macro is used in conjunction with the <a class="el" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL()</a> macro to check if data has arrived on a protosocket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2ebfe5c8a7f3173714efdf2df74fc392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_WAIT_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga99e43010ec61327164466aa2d902de45">PT_WAIT_UNTIL</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition));</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until a condition is true.</p>
<p>This macro blocks the protothread until the specified condition is true. The macro <a class="el" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA()</a> can be used to check if new data arrives when the protosocket is waiting.</p>
<p>Typically, this macro is used as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="group__pt.html#ga3d4c8bd4aada659eb34f5d2ffd3e7901">PT_THREAD</a>(thread(<span class="keyword">struct</span> <a class="code" href="structpsock.html">psock</a> *s, <span class="keyword">struct</span> <a class="code" href="structtimer.html">timer</a> *t))</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN</a>(s);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL</a>(s, PSOCK_NEWADATA(s) || <a class="code" href="group__timer.html#ga6d71dececfce707c668e6257aad5906e">timer_expired</a>(t));</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA</a>(s)) {</div>
<div class="line">    <a class="code" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO</a>(s, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    handle_timed_out(s);</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <a class="code" href="group__psock.html#ga4a264bb64ae706d53f572b1d9e4037a2">PSOCK_END</a>(s);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psock</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
    <tr><td class="paramname">condition</td><td>The condition to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa87ff36af81990e6ffe20d76d5e4606f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_WAIT_THREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__pt.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga86cc77c910c9a27b614fedf3ff8294bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psock_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpsock.html">psock</a> *&#160;</td>
          <td class="paramname"><em>psock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>buffersize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga712420c615c932642b69c6c0bb8d13ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, const char *buf, unsigned int len)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7440860cfbffad961f993737932d17d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_generator_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned short(*f)(void *), void *arg)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadb49ec06eee4fb369d8d3a414143bb14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_readbuf(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3b0505ebccc87d4c1ab7b0e875d53839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_readto(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned char c)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3178402dd725776415bf9745e7bf92ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t psock_datalen </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpsock.html">psock</a> *&#160;</td>
          <td class="paramname"><em>psock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3b19f65e48079d8105be2a99b5b4b2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char psock_newdata </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpsock.html">psock</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 3 2015 13:46:14 for RF24Ethernet - TCP/IP over RF24Network by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
