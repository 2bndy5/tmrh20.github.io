<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Newly Optimized RF24Network Layer: Performance and Data Loss: Tuning the Network</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Newly Optimized RF24Network Layer
   </div>
   <div id="projectbrief">2014 - Optimized RF24 Network Layer for NRF24L01 radios</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Performance and Data Loss: Tuning the Network </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Tips and examples for tuning the network and general operation.</p>
<div class="image">
<img src="tmrh20/topologyImage.jpg"  alt="Topology" height="75%" width="75%"/>
</div>
<h1><a class="anchor" id="Routing"></a>
Routing and Topology</h1>
<p>See <b><a href="tmrh20/topologyImage_Advanced.jpg">Advanced Topology and Routing</a></b> for advanced routing information and details.</p>
<h1><a class="anchor" id="General"></a>
Understanding Radio Communication and Topology</h1>
<p>When a transmission takes place from one radio module to another, the receiving radio will normally communicate back to the sender with an automatic acknowledgement (ACK) packet, to indicate success. If the sender does not receive an ACK, the radio automatically engages in a series of timed retries, at set intervals. The radios use techniques like addressing and numbering of payloads to manage this, but it is all done automatically, out of sight from the user.</p>
<p>When working over a radio network, some of these automated techniques can actually hinder data transmission. Retrying failed payloads over and over on a radio network can hinder communication for nearby nodes, or reduce throughput and errors on routing nodes. This new configuration uses a combination of auto-acknowledgments and software driven network-acknowledgements to manage data on the network, which enables network wide acks to be transmitted.</p>
<p>Radios in this network are linked by <b>addresses</b> assigned to <b>pipes</b>. Each radio can listen to 6 addresses on 6 pipes, therefore each radio has a parent pipe and 5 child pipes, which are used to form a tree structure. Nodes communicate directly with their parent and children nodes. Any other traffic to or from a node must be routed through the network, or sent directly.</p>
<h1><a class="anchor" id="Network_Routing"></a>
Network Routing</h1>
<p>Routing of traffic is handled invisibly to the user. If the network is constructed appropriately, nodes will route traffic automatically as required. Data transmission generally has one of two requirements, either data that fails to transmit can be discarded as new data arrives, or sending can be retried as required until complete success or failure.</p>
<p>The new routing protocol allows this to be managed at the application level as the data requires, with defaults assigned specifically to allow maximum efficiency and throughput from the RF level to the network and application level. If routing data between parent and child nodes (marked by direct links on the topology image above) the network uses built-in acknowledgement and retry functions of the chip to prevent data loss. When payloads are sent to other nodes, they need to be routed. Routing is managed using a combination of built in ACK requests, and software driven network ACKs. This allows all routing nodes to forward data very quickly, with only the final routing node confirming delivery and sending back an acknowledgement. It also helps to prevent overloading the network, as individual nodes are forced to wait until sent data has had time to traverse the network. Any received data will be routed or queued while a node is waiting for a network-ack response.</p>
<p>Example: Node 00 sends to node 01. The nodes will use the built in auto-retry and auto-ack functions.<br/>
 Example: Node 00 sends to node 011. Node 00 will send to node 01, and request -no radio ACK-. Node 01 will forward the message to 011 and request an auto radio ACK. If delivery was successful, node 01 will also forward a network ACK back to node 00, indicating success.</p>
<p>Old Functionality: Node 00 sends to node 011 using auto-ack. Node 00 first sends to 01, 01 acknowledges. Node 01 forwards the payload to 011 using auto-ack. If the payload fails between 01 and 011, node 00 has no way of knowing. The new method uses the same amount of traffic to accomplish more.</p>
<h1><a class="anchor" id="Multicasting"></a>
Multicasting</h1>
<p>Nodes are grouped by network level by default, as shown in the above image, but in multicast mode, all nodes of the same level will receive the same multicast payloads sent by other nodes to that level. Payloads in multicast mode are not acknowledged. The multicast level can be specified for any node, and any node can also be configured as a multicast relay node. Any nodes with multicast enabled can only have 4 direct child nodes, but can have any number of multicast children at the next level number up. Relay nodes will forward all received multicast payloads to the next multicast level up. Normal network payloads from indirect children can be routed through relay nodes, but should not be addressed to the relay nodes. Multicast children can send multicast payloads to their parent relay nodes to distribute messages to the other multicast child nodes of the same level. Nodes with multicasting enabled will automatically filter out duplicate payloads as long as they are received sequentially, so multicast relay nodes should call network.update() as often as possible. Hybrid networks consisting of multicast enabled, and non-multicast nodes, branches and layers is possible, so some dynamic configurations can be achieved.</p>
<h1><a class="anchor" id="Adv_Routing_Direct"></a>
Direct routing and sending</h1>
<p>The new configuration allows nodes to transmit or route traffic directly through any other nodes in range. Payloads are addressed logically to the intended recipient, and an address can be designated so the payload is physically sent to any other node for routing. The following limitations apply: </p>
<ul>
<li>Payloads logically addressed to a node should only be delivered directly to that node if it is a direct parent or child, or has the appropriate child pipes available. </li>
<li>For node 011 to send a payload directly to node 021, node 021 should not have a child node 0121. </li>
<li>Payloads can physically be sent directly to any node, providing that are logically addressed to a different node. The receiving node will route the payloads accordingly, and the delivering node will forward a network acknowledgement to the initial sender. The network ack will traverse the network just as any other payload, so if the main child-parent link to the sender is down, it will not receive acknowledgement.</li>
</ul>
<h1><a class="anchor" id="TuningOverview"></a>
Tuning Overview</h1>
<p>The RF24 radio modules are generally only capable of either sending or receiving data at any given time, but have built-in auto-retry mechanisms to prevent the loss of data. These values are adjusted automatically by the library on startup, but can be further adjusted to reduce data loss, and thus increase throughput of the network. This page is intended to provide a general overview of its operation within the context of the network library, and provide information for adjusting these values. Generally speaking, higher delays and more retries will provide less data loss, but can dramatically lower throughput depending on the scenario. Lower delays and less retries will provide faster response times and higher throughput, but data loss will be more common.</p>
<h1><a class="anchor" id="RetryTiming"></a>
Auto-Retry Timing</h1>
<p>The core radio library provides the functionality of adjusting the internal auto-retry interval of the radio modules. In the network configuration, the radios can be set to automatically retry failed transmissions at intervals ranging anywhere from 500us (.5ms) up to 4000us (4ms). When operating any number of radios larger than two, it is important to stagger the assigned intervals, to prevent the radios from interfering with each other at the radio frequency (RF) layer.</p>
<p>The library should provide fairly good working values, as it simply staggers the assigned values within groups of radios in direct communication. This value can be set manually by calling radio.setRetries(X,15); and adjusting the value of X from 1 to 15 (steps of 250us).</p>
<h1><a class="anchor" id="AutoRetry"></a>
Auto-Retry Count and Extended Timeouts</h1>
<p>The core radio library also provides the ability to adjust the internal auto-retry count of the radio modules. The default setting is 15 automatic retries per payload, and can be extended by configuring the network.txTimeout variable. This default retry count should generally be left at 15, as per the example in the above section. An interval/retry setting of (15,15) will provide 15 retrys at intervals of 4ms, taking up to 60ms per payload. The library now provides staggered timeout periods by default, but they can also be adjusted on a per-node basis.</p>
<p>The txTimeout variable is used to extend the retry count to a defined duration in milliseconds. See the network.txTimeout variable. Timeout periods of extended duration (500+) will generally not help when payloads are failing due to data collisions, it will only extend the duration of the errors. Extended duration timeouts should generally only be configured on leaf nodes that do not receive data, or on a dual-headed node.</p>
<p>This time-out value should generally be left as-is and payloads retried at set intervals.</p>
<h1><a class="anchor" id="Route_Timeout"></a>
Route Timeout</h1>
<p>When network payloads need to be routed, the delivering node will forward a network ACK to the sender to confirm receipt. The route timeout specifies how long to wait for acks from across the network. While the sender is waiting for a response, it will continue to forward payloads and queue received payloads. Failed payloads can be retried a number of times, but if more than 5 payloads are received between retries without reading them, the data may be lost. The Raspberry Pi is configured to queue up to 255 payloads, due to the additional memory available, so the network.read() method does not need to be called very often as long as network.update() is called regularly enough to prevent the radio FIFO buffers from being overrun (3 payloads stored in radio buffer) and/or manage routing. The route timeout value should not need to be adjusted under most circumstances.</p>
<h1><a class="anchor" id="DualHead"></a>
Dual Headed Operation</h1>
<p>The library now supports a dual radio configuration to further enhance network performance, while reducing errors on busy networks. Master nodes or relay nodes with a large number of child nodes can benefit greatly from a dual headed configuration, since one radio is used for receiving, and the other entirely for transmission.</p>
<p>To configure a dual headed node:</p>
<ol type="1">
<li>Edit the <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a> file, and uncomment #define DUAL_HEAD_RADIO</li>
<li>Connect another radio, using the same MOSI, MISO, and SCK lines.</li>
<li>Choose another two pins to use for CE and CS on the second radio. Connect them.</li>
<li>Setup the radio and network like so:</li>
</ol>
<div class="fragment"><div class="line">      RF24 radio(7,8);                        <span class="comment">// Using CE (7) and CS (8) for first radio</span></div>
<div class="line">      RF24 radio1(4,5);                       <span class="comment">// Using CE (4) and CS (5) for second radio</span></div>
<div class="line">      <a class="code" href="classRF24Network.html">RF24Network</a> network(radio,radio1);      <span class="comment">// Set up the network using both radios</span></div>
<div class="line"></div>
<div class="line">Then in setup(), call radio.begin(); and radio1.begin(); before network.begin();</div>
</div><!-- fragment --><ol type="1">
<li>Upload to MCU. The node will now use the first radio to receive data, and radio1 to transmit, preventing data loss on a busy network.</li>
<li>Re-comment the #define in the config file as required if configuring other single-headed radios.</li>
</ol>
<p>Any node can be configured in dual-head mode. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 29 2014 22:57:09 for Newly Optimized RF24Network Layer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
