<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Newly Optimized RF24Network Layer: RF24Network Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Newly Optimized RF24Network Layer
   </div>
   <div id="projectbrief">2014 - Optimized RF24 Network Layer for NRF24L01 radios</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRF24Network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RF24Network Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>2014 - Optimized Network Layer for RF24 Radios  
 <a href="classRF24Network.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RF24Network_8h_source.html">RF24Network.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a814229a5a4e8e30f88a4bdce05807e50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a814229a5a4e8e30f88a4bdce05807e50">RF24Network</a> (RF24 &amp;_radio)</td></tr>
<tr class="memdesc:a814229a5a4e8e30f88a4bdce05807e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the network.  <a href="#a814229a5a4e8e30f88a4bdce05807e50">More...</a><br/></td></tr>
<tr class="separator:a814229a5a4e8e30f88a4bdce05807e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0da46b2e78b2010171c9f20cba8bae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#abf0da46b2e78b2010171c9f20cba8bae">begin</a> (uint8_t _channel, uint16_t _node_address)</td></tr>
<tr class="memdesc:abf0da46b2e78b2010171c9f20cba8bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring up the network.  <a href="#abf0da46b2e78b2010171c9f20cba8bae">More...</a><br/></td></tr>
<tr class="separator:abf0da46b2e78b2010171c9f20cba8bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59983f89b09d17d7d9b0581f658a41c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ad59983f89b09d17d7d9b0581f658a41c">update</a> (void)</td></tr>
<tr class="memdesc:ad59983f89b09d17d7d9b0581f658a41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main layer loop.  <a href="#ad59983f89b09d17d7d9b0581f658a41c">More...</a><br/></td></tr>
<tr class="separator:ad59983f89b09d17d7d9b0581f658a41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e111e70bb7b95d885983ce92c89159e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a0e111e70bb7b95d885983ce92c89159e">available</a> (void)</td></tr>
<tr class="memdesc:a0e111e70bb7b95d885983ce92c89159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether there is a message available for this node.  <a href="#a0e111e70bb7b95d885983ce92c89159e">More...</a><br/></td></tr>
<tr class="separator:a0e111e70bb7b95d885983ce92c89159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fff614f10fcc1d8984b5ee5cc87a4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a04fff614f10fcc1d8984b5ee5cc87a4b">peek</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header)</td></tr>
<tr class="memdesc:a04fff614f10fcc1d8984b5ee5cc87a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next available header.  <a href="#a04fff614f10fcc1d8984b5ee5cc87a4b">More...</a><br/></td></tr>
<tr class="separator:a04fff614f10fcc1d8984b5ee5cc87a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821a40cd3c7afdff86742de2816b67fc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a821a40cd3c7afdff86742de2816b67fc">peekData</a> ()</td></tr>
<tr class="separator:a821a40cd3c7afdff86742de2816b67fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19f775fcddd334f222ae1b3072dbbe8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa19f775fcddd334f222ae1b3072dbbe8">read</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, void *message, size_t maxlen)</td></tr>
<tr class="memdesc:aa19f775fcddd334f222ae1b3072dbbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message.  <a href="#aa19f775fcddd334f222ae1b3072dbbe8">More...</a><br/></td></tr>
<tr class="separator:aa19f775fcddd334f222ae1b3072dbbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b90e07f0f89d64af07b5da0b31e3c87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a6b90e07f0f89d64af07b5da0b31e3c87">write</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, size_t len)</td></tr>
<tr class="memdesc:a6b90e07f0f89d64af07b5da0b31e3c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message.  <a href="#a6b90e07f0f89d64af07b5da0b31e3c87">More...</a><br/></td></tr>
<tr class="separator:a6b90e07f0f89d64af07b5da0b31e3c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Advanced Operation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpaf32cf1216e734b82e2b52429dae0bf6"></a>For advanced configuration of the network </p>
</td></tr>
<tr class="memitem:a8838b42717e7c9da37213b020db1f88c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a8838b42717e7c9da37213b020db1f88c">txTimeout</a></td></tr>
<tr class="memdesc:a8838b42717e7c9da37213b020db1f88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network timeout value.  <a href="#a8838b42717e7c9da37213b020db1f88c">More...</a><br/></td></tr>
<tr class="separator:a8838b42717e7c9da37213b020db1f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fd03730b6c9084cc440b4fe0177c3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a657fd03730b6c9084cc440b4fe0177c3">routeTimeout</a></td></tr>
<tr class="memdesc:a657fd03730b6c9084cc440b4fe0177c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This only affects payloads that are routed by one or more nodes.  <a href="#a657fd03730b6c9084cc440b4fe0177c3">More...</a><br/></td></tr>
<tr class="separator:a657fd03730b6c9084cc440b4fe0177c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7408ca2b2f9ab15331ba77a747f7bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a></td></tr>
<tr class="memdesc:add7408ca2b2f9ab15331ba77a747f7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enabling this will allow this node to automatically forward received multicast frames to the next highest multicast level.  <a href="#add7408ca2b2f9ab15331ba77a747f7bb">More...</a><br/></td></tr>
<tr class="separator:add7408ca2b2f9ab15331ba77a747f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c994c5fdcb2173b187c52b641aaeae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a1c994c5fdcb2173b187c52b641aaeae0">frag_ptr</a></td></tr>
<tr class="separator:a1c994c5fdcb2173b187c52b641aaeae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85150019642eb1fb4afe5f01c3b0c804"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a85150019642eb1fb4afe5f01c3b0c804">RF24Network</a> (RF24 &amp;_radio, RF24 &amp;_radio1)</td></tr>
<tr class="memdesc:a85150019642eb1fb4afe5f01c3b0c804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the network in dual head mode using two radio modules.  <a href="#a85150019642eb1fb4afe5f01c3b0c804">More...</a><br/></td></tr>
<tr class="separator:a85150019642eb1fb4afe5f01c3b0c804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb84d7556df00c933208ecf44b227a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acb84d7556df00c933208ecf44b227a4f">failures</a> (uint32_t *_fails, uint32_t *_ok)</td></tr>
<tr class="memdesc:acb84d7556df00c933208ecf44b227a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of failures and successes for all transmitted payloads, routed or sent directly.  <a href="#acb84d7556df00c933208ecf44b227a4f">More...</a><br/></td></tr>
<tr class="separator:acb84d7556df00c933208ecf44b227a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad777906b31c19c765ffe6f97a3f7feb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ad777906b31c19c765ffe6f97a3f7feb0">multicast</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, size_t len, uint8_t level)</td></tr>
<tr class="memdesc:ad777906b31c19c765ffe6f97a3f7feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a multicast message to multiple nodes at once Allows messages to be rapidly broadcast through the network.  <a href="#ad777906b31c19c765ffe6f97a3f7feb0">More...</a><br/></td></tr>
<tr class="separator:ad777906b31c19c765ffe6f97a3f7feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel</a> (uint8_t level)</td></tr>
<tr class="memdesc:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, multicast addresses are divided into levels.  <a href="#a4fb7c61eee75d708a4ba20bb1caec54f">More...</a><br/></td></tr>
<tr class="separator:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbcdf229d67fe57d324cb26d64f5841"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#abcbcdf229d67fe57d324cb26d64f5841">write</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, size_t len, uint16_t writeDirect)</td></tr>
<tr class="memdesc:abcbcdf229d67fe57d324cb26d64f5841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a direct payload.  <a href="#abcbcdf229d67fe57d324cb26d64f5841">More...</a><br/></td></tr>
<tr class="separator:abcbcdf229d67fe57d324cb26d64f5841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8921392fbd695721c3d137f139a2a56e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a8921392fbd695721c3d137f139a2a56e">sleepNode</a> (unsigned int cycles, int interruptPin)</td></tr>
<tr class="memdesc:a8921392fbd695721c3d137f139a2a56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep this node - Still Under Development.  <a href="#a8921392fbd695721c3d137f139a2a56e">More...</a><br/></td></tr>
<tr class="separator:a8921392fbd695721c3d137f139a2a56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09129760ac9b171833af3055b2b6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog</a> (uint8_t prescalar)</td></tr>
<tr class="memdesc:acb09129760ac9b171833af3055b2b6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the watchdog timer for sleep mode using the number 0 through 10 to represent the following time periods:<br/>
 wdt_16ms = 0, wdt_32ms, wdt_64ms, wdt_128ms, wdt_250ms, wdt_500ms, wdt_1s, wdt_2s, wdt_4s, wdt_8s.  <a href="#acb09129760ac9b171833af3055b2b6f5">More...</a><br/></td></tr>
<tr class="separator:acb09129760ac9b171833af3055b2b6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2274c0548e35b5182a2f6ced222d0699"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a2274c0548e35b5182a2f6ced222d0699">parent</a> () const </td></tr>
<tr class="memdesc:a2274c0548e35b5182a2f6ced222d0699"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node's parent address.  <a href="#a2274c0548e35b5182a2f6ced222d0699">More...</a><br/></td></tr>
<tr class="separator:a2274c0548e35b5182a2f6ced222d0699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa4a11edb3860f4a0e3808bccad36a5dc">addressOfPipe</a> (uint16_t node, uint8_t pipeNo)</td></tr>
<tr class="memdesc:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provided a node address and a pipe number, will return the <a class="el" href="classRF24Network.html" title="2014 - Optimized Network Layer for RF24 Radios ">RF24Network</a> address of that child pipe for that node.  <a href="#aa4a11edb3860f4a0e3808bccad36a5dc">More...</a><br/></td></tr>
<tr class="separator:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41da035bd7f469ea4364a06ab4efd1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ab41da035bd7f469ea4364a06ab4efd1b">is_valid_address</a> (uint16_t node)</td></tr>
<tr class="separator:ab41da035bd7f469ea4364a06ab4efd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>2014 - Optimized Network Layer for RF24 Radios </p>
<p>This class implements an OSI Network Layer using nRF24L01(+) radios driven by RF24 library. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="helloworld_rx_8ino-example.html#_a0">helloworld_rx.ino</a>, <a class="el" href="helloworld_tx_8ino-example.html#_a0">helloworld_tx.ino</a>, <a class="el" href="Network_Ping_8ino-example.html#_a0">Network_Ping.ino</a>, <a class="el" href="Network_Ping_Sleep_8ino-example.html#_a0">Network_Ping_Sleep.ino</a>, and <a class="el" href="sensornet_8pde-example.html#_a0">sensornet.pde</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a814229a5a4e8e30f88a4bdce05807e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24Network::RF24Network </td>
          <td>(</td>
          <td class="paramtype">RF24 &amp;&#160;</td>
          <td class="paramname"><em>_radio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radio</td><td>The underlying radio driver instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85150019642eb1fb4afe5f01c3b0c804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24Network::RF24Network </td>
          <td>(</td>
          <td class="paramtype">RF24 &amp;&#160;</td>
          <td class="paramname"><em>_radio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF24 &amp;&#160;</td>
          <td class="paramname"><em>_radio1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the network in dual head mode using two radio modules. </p>
<dl class="section note"><dt>Note</dt><dd>Not working on RPi. Radios will share MISO, MOSI and SCK pins, but require separate CE,CS pins. <div class="fragment"><div class="line">RF24 radio(7,8);</div>
<div class="line">RF24 radio1(4,5);</div>
<div class="line"><a class="code" href="classRF24Network.html#a814229a5a4e8e30f88a4bdce05807e50">RF24Network</a>(radio.radio1);</div>
</div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radio</td><td>The underlying radio driver instance </td></tr>
    <tr><td class="paramname">_radio1</td><td>The second underlying radio driver instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abf0da46b2e78b2010171c9f20cba8bae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::begin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_node_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bring up the network. </p>
<dl class="section warning"><dt>Warning</dt><dd>Be sure to 'begin' the radio first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel</td><td>The RF channel to operate on </td></tr>
    <tr><td class="paramname">_node_address</td><td>The logical address of this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59983f89b09d17d7d9b0581f658a41c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main layer loop. </p>
<p>This function must be called regularly to keep the layer going. This is where all the action happens! </p>

</div>
</div>
<a class="anchor" id="a0e111e70bb7b95d885983ce92c89159e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether there is a message available for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether there is a message available for this node </dd></dl>

</div>
</div>
<a class="anchor" id="a04fff614f10fcc1d8984b5ee5cc87a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t RF24Network::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next available header. </p>
<p>Reads the next available header without advancing to the next incoming message. Useful for doing a switch on the message type</p>
<p>If there is no message available, the header is not touched</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The header (envelope) of the next message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a821a40cd3c7afdff86742de2816b67fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::peekData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa19f775fcddd334f222ae1b3072dbbe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t RF24Network::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The header (envelope) of this message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Pointer to memory where the message should be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxlen</td><td>The largest message size which can be held in <code>message</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes copied into <code>message</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b90e07f0f89d64af07b5da0b31e3c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message. </p>
<dl class="section note"><dt>Note</dt><dd>Raspberry Pi now supports fragmentation for very long messages, send as normal Arduino, ATTiny devices need to be updated if used with RPi, and will handle routing of fragmented messages, but cannot receive them properly</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">header</td><td>The header (envelope) of this message. The critical thing to fill in is the <code>to_node</code> field so we know where to send the message. It is then updated with the details of the actual header sent. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">message</td><td>Pointer to memory where the message is located </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>The size of the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message was successfully received </dd></dl>

</div>
</div>
<a class="anchor" id="acb84d7556df00c933208ecf44b227a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::failures </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>_fails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of failures and successes for all transmitted payloads, routed or sent directly. </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> fails, success;  </div>
<div class="line">network.failures(&amp;fails,&amp;success);  </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad777906b31c19c765ffe6f97a3f7feb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::multicast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a multicast message to multiple nodes at once Allows messages to be rapidly broadcast through the network. </p>
<p>Multicasting is arranged in levels, with all nodes on the same level listening to the same address Levels are assigned by network level ie: nodes 01-05: Level 1, nodes 011-055: Level 2 </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f" title="By default, multicast addresses are divided into levels. ">multicastLevel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>Pointer to memory where the message is located </td></tr>
    <tr><td class="paramname">len</td><td>The size of the message </td></tr>
    <tr><td class="paramname">level</td><td>Multicast level to broadcast to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message was successfully received </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb7c61eee75d708a4ba20bb1caec54f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::multicastLevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, multicast addresses are divided into levels. </p>
<p>Nodes 1-5 share a multicast address, nodes n1-n5 share a multicast address, and nodes n11-n55 share a multicast address. This option is used to override the defaults, and create custom multicast groups that all share a single address. The level should be specified in decimal format 1-6 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Levels 1 to 6 are available. All nodes at the same level will receive the same messages if in range. Messages will be routed in order of level, low to high by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcbcdf229d67fe57d324cb26d64f5841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>writeDirect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a direct payload. </p>
<p>This allows routing or sending messages outside of the usual routing paths. The same as write, but a physical address is specified as the last option. The payload will be written to the physical address, and routed as necessary by the recipient </p>

</div>
</div>
<a class="anchor" id="a8921392fbd695721c3d137f139a2a56e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::sleepNode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep this node - Still Under Development. </p>
<dl class="section note"><dt>Note</dt><dd>NEW - Nodes can now be slept while the radio is not actively transmitting. This must be manually enabled by uncommenting the #define ENABLE_SLEEP_MODE in <a class="el" href="RF24Network__config_8h_source.html">RF24Network_config.h</a> </dd>
<dd>
Setting the interruptPin to 255 will disable interrupt wake-ups </dd>
<dd>
The watchdog timer should be configured in setup() if using sleep mode. This function will sleep the node, with the radio still active in receive mode.</dd></dl>
<p>The node can be awoken in two ways, both of which can be enabled simultaneously:</p>
<ol type="1">
<li>An interrupt - usually triggered by the radio receiving a payload. Must use pin 2 (interrupt 0) or 3 (interrupt 1) on Uno, Nano, etc.</li>
<li>The watchdog timer waking the MCU after a designated period of time, can also be used instead of delays to control transmission intervals. <div class="fragment"><div class="line"><span class="keywordflow">if</span>(!network.available()){ network.sleepNode(1,0); }  <span class="comment">//Sleeps the node for 1 second or a payload is received</span></div>
<div class="line"></div>
<div class="line">Other options:</div>
<div class="line">network.sleepNode(0,0);         <span class="comment">// Sleep this node for the designated time period, or a payload is received.</span></div>
<div class="line">network.sleepNode(1,255);       <span class="comment">// Sleep this node for 1 cycle. Do not wake up until then, even if a payload is received ( no interrupt )</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5" title="Set up the watchdog timer for sleep mode using the number 0 through 10 to represent the following tim...">setup_watchdog()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The node will sleep in cycles of 1s. Using 2 will sleep 2 WDT cycles, 3 sleeps 3WDT cycles... </td></tr>
    <tr><td class="paramname">interruptPin</td><td>The interrupt number to use (0,1) for pins two and three on Uno,Nano. More available on Mega etc. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="acb09129760ac9b171833af3055b2b6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::setup_watchdog </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prescalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the watchdog timer for sleep mode using the number 0 through 10 to represent the following time periods:<br/>
 wdt_16ms = 0, wdt_32ms, wdt_64ms, wdt_128ms, wdt_250ms, wdt_500ms, wdt_1s, wdt_2s, wdt_4s, wdt_8s. </p>
<div class="fragment"><div class="line"><a class="code" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog</a>(7);   <span class="comment">// Sets the WDT to trigger every second</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescalar</td><td>The WDT prescaler to define how often the node will wake up. When defining sleep mode cycles, this time period is 1 cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2274c0548e35b5182a2f6ced222d0699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This node's parent address. </p>
<dl class="section return"><dt>Returns</dt><dd>This node's parent address, or -1 if this is the base </dd></dl>

</div>
</div>
<a class="anchor" id="aa4a11edb3860f4a0e3808bccad36a5dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::addressOfPipe </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipeNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provided a node address and a pipe number, will return the <a class="el" href="classRF24Network.html" title="2014 - Optimized Network Layer for RF24 Radios ">RF24Network</a> address of that child pipe for that node. </p>

</div>
</div>
<a class="anchor" id="ab41da035bd7f469ea4364a06ab4efd1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::is_valid_address </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Addresses are specified in octal: 011, 034 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if a supplied address is valid </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8838b42717e7c9da37213b020db1f88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24Network::txTimeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Network timeout value. </p>
<dl class="section note"><dt>Note</dt><dd>: Optimization:This value is automatically assigned based on the node address to reduce errors and increase throughput of the network.</dd></dl>
<p>Sets the timeout period for individual payloads in milliseconds at staggered intervals. Payloads will be retried automatically until success or timeout Set to 0 to use the normal auto retry period defined by radio.setRetries() </p>

</div>
</div>
<a class="anchor" id="a657fd03730b6c9084cc440b4fe0177c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::routeTimeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This only affects payloads that are routed by one or more nodes. </p>
<p>This specifies how long to wait for an ack from across the network. Radios routing directly to their parent or children nodes do not utilize this value.Timeout for routed payloads </p>

</div>
</div>
<a class="anchor" id="add7408ca2b2f9ab15331ba77a747f7bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::multicastRelay</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enabling this will allow this node to automatically forward received multicast frames to the next highest multicast level. </p>
<p>Duplicate frames are filtered out, so multiple forwarding nodes at the same level should not interfere </p>

</div>
</div>
<a class="anchor" id="a1c994c5fdcb2173b187c52b641aaeae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a>* RF24Network::frag_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 24 2014 22:59:19 for Newly Optimized RF24Network Layer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
