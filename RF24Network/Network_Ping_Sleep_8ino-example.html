<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Newly Optimized RF24Network Layer: Network_Ping_Sleep.ino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Newly Optimized RF24Network Layer
   </div>
   <div id="projectbrief">2014-2015 - Optimized RF24 Network Layer for NRF24L01 radios</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Network_Ping_Sleep.ino</div>  </div>
</div><!--header-->
<div class="contents">
<p>Example: This is almost exactly the same as the Network_Ping example, but with use of the integrated sleep mode. This example demonstrates how nodes on the network utilize sleep mode to conserve power. For example, the radio itself will draw about 13.5mA in receive mode. In sleep mode, it will use as little as 22ua (.000022mA) of power when not actively transmitting or receiving data. In addition, the Arduino is powered down as well, dropping network power consumption dramatically compared to previous capabilities. <br />
 Note: Sleeping nodes generate traffic that will wake other nodes up. This may be mitigated with further modifications. Sleep payloads are currently always routed to the master node, which will wake up intermediary nodes. Routing nodes can be configured to go back to sleep immediately. The displayed millis() count will give an indication of how much a node has been sleeping compared to the others, as millis() will not increment while a node sleeps. <br />
</p><ul>
<li>Using this sketch, each node will send a ping to every other node in the network every few seconds.<br />
</li>
<li>The <a class="el" href="classRF24Network.html" title="2014-2015 - Optimized Network Layer for RF24 Radios ">RF24Network</a> library will route the message across the mesh to the correct node.<br />
</li>
</ul>
<div class="fragment"><div class="line">/*</div>
<div class="line"> Copyright (C) 2011 James Coliz, Jr. &lt;maniacbug@ymail.com&gt;</div>
<div class="line"></div>
<div class="line"> This program is free software; you can redistribute it and/or</div>
<div class="line"> modify it under the terms of the GNU General Public License</div>
<div class="line"> version 2 as published by the Free Software Foundation.</div>
<div class="line"> </div>
<div class="line"> 2014 - TMRh20: New sketch included with updated library</div>
<div class="line"> */</div>
<div class="line"></div>
<div class="line">/**</div>
<div class="line"> * Example: Network topology, and pinging across a tree/mesh network with sleeping nodes</div>
<div class="line"> *</div>
<div class="line"> * Using this sketch, each node will send a ping to every other node in the network every few seconds. </div>
<div class="line"> * The RF24Network library will route the message across the mesh to the correct node.</div>
<div class="line"> *</div>
<div class="line"> * This sketch demonstrates the new functionality of nodes sleeping in STANDBY-I mode. In receive mode,</div>
<div class="line"> * the radio will draw about 13.5 mA. In STANDBY-I mode, the radio draws .000022mA, and is able to awake</div>
<div class="line"> * when payloads are received.</div>
<div class="line"> *</div>
<div class="line"> * How it Works:</div>
<div class="line"> * The enhanced sleep mode utilizes the ACK payload functionality, as radios that are in Primary Transmitter</div>
<div class="line"> * mode (PTX) are able to receive ACK payloads while in STANDBY-I mode. </div>
<div class="line"> * 1. The radio is configured to use Dynamic Payloads and ACK payloads with Auto-Ack enabled </div>
<div class="line"> * 2. The radio enters PTX mode and attaches an interrupt handler to the radio interrupt input pin (pin 2)</div>
<div class="line"> * 3. The radio uses the Watchdog Timer to awake at set 1 second intervals in this example</div>
<div class="line"> * 4. Every interval, it sends out a &#39;sleep&#39; payload and goes back to sleep. Incoming payloads will then be treated as ACK payloads, while the radio remains in STANDBY-I mode.</div>
<div class="line"> * 5. If an interrupt is triggered, the radio wakes up</div>
<div class="line"> * 6. When a message is sent to the sleeping node, the interrupt triggers a wake up, the MCU</div>
<div class="line"> * grabs the payload, and switches back to receive mode in case more data is on its way.</div>
<div class="line"> *</div>
<div class="line"> * The node (Arduino) power use can be reduced further by disabling unnessessary systems via the Power Reduction Register(s) (PRR).</div>
<div class="line"> */</div>
<div class="line"></div>
<div class="line">#include &lt;avr/pgmspace.h&gt;</div>
<div class="line">#include &lt;RF24Network.h&gt;</div>
<div class="line">#include &lt;RF24.h&gt;</div>
<div class="line">#include &lt;SPI.h&gt;</div>
<div class="line">#include &quot;printf.h&quot;</div>
<div class="line">#include &lt;avr/sleep.h&gt;</div>
<div class="line">#include &lt;avr/power.h&gt;</div>
<div class="line"></div>
<div class="line">/***********************************************************************</div>
<div class="line">************* Set the Node Address *************************************</div>
<div class="line">/***********************************************************************/</div>
<div class="line"></div>
<div class="line">// These are the Octal addresses that will be assigned</div>
<div class="line">const uint16_t node_address_set[10] = { 00, 02, 05, 012, 015, 022, 025, 032, 035, 045 };</div>
<div class="line"></div>
<div class="line">// 0 = Master</div>
<div class="line">// 1-2 (02,05)   = Children of Master(00)</div>
<div class="line">// 3,5 (012,022) = Children of (02)</div>
<div class="line">// 4,6 (015,025) = Children of (05)</div>
<div class="line">// 7   (032)     = Child of (02)</div>
<div class="line">// 8,9 (035,045) = Children of (05)</div>
<div class="line"></div>
<div class="line">uint8_t NODE_ADDRESS = 1; // Use numbers 0 through 9 to select an address from the array</div>
<div class="line"></div>
<div class="line">/***********************************************************************/</div>
<div class="line">/***********************************************************************/</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">RF24 radio(7,8);                                    // CE &amp; CS pins to use (Using 7,8 on Uno,Nano)</div>
<div class="line">RF24Network network(radio); </div>
<div class="line"></div>
<div class="line">uint16_t this_node;                                  // Our node address</div>
<div class="line"></div>
<div class="line">const unsigned long interval = 1000; // ms           // Delay manager to send pings regularly. Because of sleepNode(), this is largely irrelevant.</div>
<div class="line">unsigned long last_time_sent;</div>
<div class="line"></div>
<div class="line">const short max_active_nodes = 10;                    // Array of nodes we are aware of</div>
<div class="line">uint16_t active_nodes[max_active_nodes];</div>
<div class="line">short num_active_nodes = 0;</div>
<div class="line">short next_ping_node_index = 0;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">bool send_T(uint16_t to);                              // Prototypes for functions to send &amp; handle messages</div>
<div class="line">bool send_N(uint16_t to);</div>
<div class="line">void handle_T(RF24NetworkHeader&amp; header);</div>
<div class="line">void handle_N(RF24NetworkHeader&amp; header);</div>
<div class="line">void add_node(uint16_t node);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">//This is for sleep mode. It is not really required, as users could just use the number 0 through 10</div>
<div class="line">typedef enum { wdt_16ms = 0, wdt_32ms, wdt_64ms, wdt_128ms, wdt_250ms, wdt_500ms, wdt_1s, wdt_2s, wdt_4s, wdt_8s } wdt_prescalar_e;</div>
<div class="line"></div>
<div class="line">unsigned long awakeTime = 500;                          // How long in ms the radio will stay awake after leaving sleep mode</div>
<div class="line">unsigned long sleepTimer = 0;                           // Used to keep track of how long the system has been awake</div>
<div class="line"></div>
<div class="line">void setup(){</div>
<div class="line">  </div>
<div class="line">  Serial.begin(115200);</div>
<div class="line">  printf_begin();</div>
<div class="line">  printf_P(PSTR(&quot;\n\rRF24Network/examples/meshping/\n\r&quot;));</div>
<div class="line"></div>
<div class="line">  this_node = node_address_set[NODE_ADDRESS];            // Which node are we?</div>
<div class="line">  </div>
<div class="line">  SPI.begin();                                           // Bring up the RF network</div>
<div class="line">  radio.begin();</div>
<div class="line">  radio.setPALevel(RF24_PA_HIGH);</div>
<div class="line">  network.begin(/*channel*/ 100, /*node address*/ this_node );</div>
<div class="line"></div>
<div class="line">/******************************** This is the configuration for sleep mode ***********************/</div>
<div class="line">  network.setup_watchdog(wdt_1s);                       //The watchdog timer will wake the MCU and radio every second to send a sleep payload, then go back to sleep</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">void loop(){</div>
<div class="line">    </div>
<div class="line">  network.update();                                      // Pump the network regularly</div>
<div class="line"></div>
<div class="line">   while ( network.available() )  {                      // Is there anything ready for us?</div>
<div class="line">     </div>
<div class="line">    RF24NetworkHeader header;                            // If so, take a look at it</div>
<div class="line">    network.peek(header);</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line">      switch (header.type){                              // Dispatch the message to the correct handler.</div>
<div class="line">        case &#39;T&#39;: handle_T(header); break;</div>
<div class="line">        case &#39;N&#39;: handle_N(header); break;</div>
<div class="line">        </div>
<div class="line">   /************* SLEEP MODE *********/</div>
<div class="line">  // Note: A &#39;sleep&#39; header has been defined, and should only need to be ignored if a node is routing traffic to itself</div>
<div class="line">  // The header is defined as:  RF24NetworkHeader sleepHeader(/*to node*/ 00, /*type*/ &#39;S&#39; /*Sleep*/);    </div>
<div class="line">         case &#39;S&#39;: /*This is a sleep payload, do nothing*/ break;</div>
<div class="line">        </div>
<div class="line">        default:  printf_P(PSTR(&quot;*** WARNING *** Unknown message type %c\n\r&quot;),header.type);</div>
<div class="line">                  network.read(header,0,0);</div>
<div class="line">                  break;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">/***************************** CALLING THE NEW SLEEP FUNCTION ************************/    </div>
<div class="line"></div>
<div class="line">  if(millis() - sleepTimer &gt; awakeTime&amp;&amp; NODE_ADDRESS){  // Want to make sure the Arduino stays awake for a little while when data comes in. Do NOT sleep if master node.</div>
<div class="line">     Serial.println(&quot;Sleep&quot;);</div>
<div class="line">     sleepTimer = millis();                           // Reset the timer value</div>
<div class="line">     delay(100);                                      // Give the Serial print some time to finish up</div>
<div class="line">     radio.stopListening();                           // Switch to PTX mode. Payloads will be seen as ACK payloads, and the radio will wake up</div>
<div class="line">     network.sleepNode(8,0);                          // Sleep the node for 8 cycles of 1second intervals</div>
<div class="line">     Serial.println(&quot;Awake&quot;); </div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">   //Examples:</div>
<div class="line">   // network.sleepNode( cycles, interrupt-pin );</div>
<div class="line">   // network.sleepNode(0,0);         // The WDT is configured in this example to sleep in cycles of 1 second. This will sleep 1 second, or until a payload is received </div>
<div class="line">   // network.sleepNode(1,255);       // Sleep this node for 1 second. Do not wake up until then, even if a payload is received ( no interrupt ) Payloads will be lost.</div>
<div class="line">    </div>
<div class="line">                                /****  end sleep section ***/  </div>
<div class="line">  </div>
<div class="line">  </div>
<div class="line">  unsigned long now = millis();                         // Send a ping to the next node every &#39;interval&#39; ms</div>
<div class="line">  if ( now - last_time_sent &gt;= interval ){</div>
<div class="line">    last_time_sent = now;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    uint16_t to = 00;                                   // Who should we send to? By default, send to base</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    if ( num_active_nodes ){                            // Or if we have active nodes,</div>
<div class="line">        to = active_nodes[next_ping_node_index++];      // Send to the next active node</div>
<div class="line">        if ( next_ping_node_index &gt; num_active_nodes ){ // Have we rolled over?</div>
<div class="line">            next_ping_node_index = 0;                   // Next time start at the beginning</div>
<div class="line">            to = 00;                                    // This time, send to node 00.</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    bool ok;</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line">    if ( this_node &gt; 00 || to == 00 ){                    // Normal nodes send a &#39;T&#39; ping</div>
<div class="line">        ok = send_T(to);   </div>
<div class="line">    }else{                                                // Base node sends the current active nodes out</div>
<div class="line">        ok = send_N(to);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    if (ok){                                              // Notify us of the result</div>
<div class="line">        printf_P(PSTR(&quot;%lu: APP Send ok\n\r&quot;),millis());</div>
<div class="line">    }else{</div>
<div class="line">        printf_P(PSTR(&quot;%lu: APP Send failed\n\r&quot;),millis());</div>
<div class="line">        last_time_sent -= 100;                            // Try sending at a different time next time</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">/**</div>
<div class="line"> * Send a &#39;T&#39; message, the current time</div>
<div class="line"> */</div>
<div class="line">bool send_T(uint16_t to)</div>
<div class="line">{</div>
<div class="line">  RF24NetworkHeader header(/*to node*/ to, /*type*/ &#39;T&#39; /*Time*/);</div>
<div class="line">  </div>
<div class="line">  // The &#39;T&#39; message that we send is just a ulong, containing the time</div>
<div class="line">  unsigned long message = millis();</div>
<div class="line">  printf_P(PSTR(&quot;---------------------------------\n\r&quot;));</div>
<div class="line">  printf_P(PSTR(&quot;%lu: APP Sending %lu to 0%o...\n\r&quot;),millis(),message,to);</div>
<div class="line">  return network.write(header,&amp;message,sizeof(unsigned long));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">/**</div>
<div class="line"> * Send an &#39;N&#39; message, the active node list</div>
<div class="line"> */</div>
<div class="line">bool send_N(uint16_t to)</div>
<div class="line">{</div>
<div class="line">  RF24NetworkHeader header(/*to node*/ to, /*type*/ &#39;N&#39; /*Time*/);</div>
<div class="line">  </div>
<div class="line">  printf_P(PSTR(&quot;---------------------------------\n\r&quot;));</div>
<div class="line">  printf_P(PSTR(&quot;%lu: APP Sending active nodes to 0%o...\n\r&quot;),millis(),to);</div>
<div class="line">  return network.write(header,active_nodes,sizeof(active_nodes));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">/**</div>
<div class="line"> * Handle a &#39;T&#39; message</div>
<div class="line"> * Add the node to the list of active nodes</div>
<div class="line"> */</div>
<div class="line">void handle_T(RF24NetworkHeader&amp; header){</div>
<div class="line"></div>
<div class="line">  unsigned long message;                                                                      // The &#39;T&#39; message is just a ulong, containing the time</div>
<div class="line">  network.read(header,&amp;message,sizeof(unsigned long));</div>
<div class="line">  printf_P(PSTR(&quot;%lu: APP Received %lu from 0%o\n\r&quot;),millis(),message,header.from_node);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  if ( header.from_node != this_node || header.from_node &gt; 00 )                                // If this message is from ourselves or the base, don&#39;t bother adding it to the active nodes.</div>
<div class="line">    add_node(header.from_node);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">/**</div>
<div class="line"> * Handle an &#39;N&#39; message, the active node list</div>
<div class="line"> */</div>
<div class="line">void handle_N(RF24NetworkHeader&amp; header)</div>
<div class="line">{</div>
<div class="line">  static uint16_t incoming_nodes[max_active_nodes];</div>
<div class="line"></div>
<div class="line">  network.read(header,&amp;incoming_nodes,sizeof(incoming_nodes));</div>
<div class="line">  printf_P(PSTR(&quot;%lu: APP Received nodes from 0%o\n\r&quot;),millis(),header.from_node);</div>
<div class="line"></div>
<div class="line">  int i = 0;</div>
<div class="line">  while ( i &lt; max_active_nodes &amp;&amp; incoming_nodes[i] &gt; 00 )</div>
<div class="line">    add_node(incoming_nodes[i++]);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">/**</div>
<div class="line"> * Add a particular node to the current list of active nodes</div>
<div class="line"> */</div>
<div class="line">void add_node(uint16_t node){</div>
<div class="line">  </div>
<div class="line">  short i = num_active_nodes;                                    // Do we already know about this node?</div>
<div class="line">  while (i--)  {</div>
<div class="line">    if ( active_nodes[i] == node )</div>
<div class="line">        break;</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  if ( i == -1 &amp;&amp; num_active_nodes &lt; max_active_nodes ){         // If not, add it to the table</div>
<div class="line">      active_nodes[num_active_nodes++] = node; </div>
<div class="line">      printf_P(PSTR(&quot;%lu: APP Added 0%o to list of active nodes.\n\r&quot;),millis(),node);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 15 2018 06:25:59 for Newly Optimized RF24Network Layer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
